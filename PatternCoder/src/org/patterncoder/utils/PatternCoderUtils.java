/* Copyright (C) 2005 - 2007 the patternCoder team, http://www.patterncoder.org

 This file is part of the patternCoder application

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License along
 with this program; if not, write to the Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
package org.patterncoder.utils;

import bluej.extensions.BPackage;
import bluej.extensions.PackageNotFoundException;
import bluej.extensions.ProjectNotOpenException;
import java.io.File;
import java.io.IOException;
import org.patterncoder.PatternCoder;
import org.patterncoder.dataModel.Pattern;
import org.patterncoder.dataModel.PatternComponent;

/**
 *
 * @author Siebler
 */
public class PatternCoderUtils
{
    private PatternCoderUtils()
    {
    }

    /**
     * Checks a source name against a list of known invalid characters. Returns
     * a boolean value indicating wether the name is valid or not.
     *
     * @param name The name that requires a check for invalid characters
     * @return returns true if the name is well formaed and valid. False is
     * returned if the name is invalid.
     */
    public static boolean verifyName(String name)
    {
        char[] INVALID_CHARS =
        {
            '!', '"', '%', '`', ' ', '~', '#', '^', '&', '*', '(', ')', '+', '=', '{', '}', '[', ']', '@', ':', ';', '?', '>', '<', '|'
        };
        boolean wellFormed = true;

        if (name == null || name.isEmpty())
        {
            wellFormed = false;
        }
        else
        {
            for (int i = 0; i < INVALID_CHARS.length; i++)
            {
                Character check = INVALID_CHARS[i];
                if (name.contains(check.toString()))
                {
                    wellFormed = false;
                    break;
                }
            }
        }
        return wellFormed;
    }

    /**
     * PatternImplementer generates all sources needed for a particular pattern,
     * and is used to add them to the BlueJ project. <p> Generates first of all
     * the java source file for each of the components and copies them to the
     * correct project directory. <p> The classes are then added to the project,
     * and the package reloaded in order to display all associations between
     * classes.
     *
     * @author Michael Nairn
     */
    public static void createFiles(Pattern currentPattern)
            throws IOException, ProjectNotOpenException, PackageNotFoundException
    {
        String CLASS_NAME = "\\$CLASSNAME";
        String PACKAGE_LINE = "\\$PKGLINE";
        String DEPENDANT_CLASS = "\\$DEPENDANT";
        PatternComponent[] allComponents = currentPattern.getAllComponents();
        BlueJHandler instance = BlueJHandler.getInstance();
        String packageName = instance.getCurrentPackageName();
        String packageLine;
        if (packageName == null || packageName.isEmpty())
        {
            packageLine = "";
        }
        else
        {
            packageLine = "package " + packageName + ";";
        }
        for (PatternComponent tempCompo : allComponents)
        {
            String klassenName = tempCompo.getClassName();
            // name and directory of target .java-file
            BPackage myPackage = FileHandler.getMyPackage();
            File currentPackageDir = myPackage.getDir();
            String fileName = currentPackageDir.getAbsolutePath() + "/" + klassenName + ".java";

            String template = tempCompo.getTemplate();
            template = template.replaceAll(CLASS_NAME, klassenName);
            template = template.replaceAll(PACKAGE_LINE, packageLine);

            String[] deps = tempCompo.getAllDependencies();
            for (String dep : deps)
            {
                String expression = DEPENDANT_CLASS + dep;
                int componentID = Integer.parseInt(dep) - 1;
                String classNameOfDep = currentPattern.getComponent(componentID).getClassName();
                template = template.replaceAll(expression, classNameOfDep);
            }
            template = template.concat("\n\n/*\n "
                    + "* Source file generated by patternCoder for BlueJ Version " + PatternCoder.VERSION + ".\n"
                    + "* For more info, please visit " + PatternCoder.EXT_URL + "\n "
                    + "*/");
            Utils.writeUTF8(fileName, template);
        }
        FileHandler.reloadPackage();
        instance.reload();
    }
}
